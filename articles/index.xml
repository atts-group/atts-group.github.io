<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>文章 on ATTS</title>
    <link>https://codenow.me/articles/</link>
    <description>Recent content in 文章 on ATTS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 15 Mar 2019 07:28:29 +0000</lastBuildDate>
    
	<atom:link href="https://codenow.me/articles/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 RMDBS 存在树结构数据</title>
      <link>https://codenow.me/articles/rmdbs-tree-datastruct/</link>
      <pubDate>Sun, 24 Mar 2019 23:41:36 +0800</pubDate>
      
      <guid>https://codenow.me/articles/rmdbs-tree-datastruct/</guid>
      <description>在关系型数据库中存储树形结构是比较麻烦的事情，因为数据库都是基于行存储的结构，要满足树形数据结构的添加、删除、查询、修改是一件比较棘手的事情。
已经有一些解决方案可以解决：
这篇文章介绍一下，使用「闭包表」来处理树形结构存储。
选择「闭包表」主要是基于查询、插入、删除、移动都比较简单，更要的是都可以使用一条 SQL 就能处理完成。
CREATE TABLE Comments ( comment_id SERIAL PRIMARY KEY, comment TEXT NOT NULL ); 树形结构典型就是评论和部门成员关系，以评论为例，我们同时又要支持完整增删改查的功能，大致结构如下： 为了满足这种复杂的关系，需要有另外一个表来存储这种结构。
CREATE TABLE TreePaths ( ancestor BIGINT NOT NULL, descendant BIGINT NOT NULL, PRIMARY KEY(ancestor, descendant), FOREIGN KEY (ancestor) REFERENCES Comments(comment_id), FOREIGN KEY (descendant) REFERENCES Comments(comment_id) ); ancestor 作为每个评论节点的祖先，descendant 作为每个评论节点的后代。
 这里的祖先和后代都是泛指所有祖先和后代，而不是特指直接的祖先和后代
 接着构造一批数据插入 Comments 和 Tree Paths 中
insert into comments(comment_id, comment) values (1, &amp;#39;这个 Bug 的成因 是什么&amp;#39;); insert into comments(comment_id, comment) values (2, &amp;#39;我觉得是一个空指针&amp;#39;); insert into comments(comment_id, comment) values (3, &amp;#39;不，我查过了&amp;#39;); insert into comments(comment_id, comment) values (4, &amp;#39;我们需要查无效输入&amp;#39;); insert into comments(comment_id, comment) values (5, &amp;#39;是的，那是个问题&amp;#39;); insert into comments(comment_id, comment) values (6, &amp;#39;好，查一下吧&amp;#39;); insert into comments(comment_id, comment) values (7, &amp;#39;解决了&amp;#39;); insert into treepaths(ancestor, descendant) values (1, 1); insert into treepaths(ancestor, descendant) values (1, 2); insert into treepaths(ancestor, descendant) values (1, 3); insert into treepaths(ancestor, descendant) values (1, 4); insert into treepaths(ancestor, descendant) values (1, 5); insert into treepaths(ancestor, descendant) values (1, 6); insert into treepaths(ancestor, descendant) values (1, 7); insert into treepaths(ancestor, descendant) values (2, 2); insert into treepaths(ancestor, descendant) values (2, 3); insert into treepaths(ancestor, descendant) values (3, 3); insert into treepaths(ancestor, descendant) values (4, 4); insert into treepaths(ancestor, descendant) values (4, 5); insert into treepaths(ancestor, descendant) values (4, 6); insert into treepaths(ancestor, descendant) values (4, 7); insert into treepaths(ancestor, descendant) values (5, 5); insert into treepaths(ancestor, descendant) values (6, 6); insert into treepaths(ancestor, descendant) values (6, 7); insert into treepaths(ancestor, descendant) values (7, 7); 这里需要解释一下 treepaths 存储关系的逻辑：</description>
    </item>
    
    <item>
      <title>[Go]Exercise of a Tour of Go</title>
      <link>https://codenow.me/articles/goexercise-of-a-tour-of-go/</link>
      <pubDate>Sun, 24 Mar 2019 22:58:30 +0800</pubDate>
      
      <guid>https://codenow.me/articles/goexercise-of-a-tour-of-go/</guid>
      <description>这周学了学 golang，做个记录
学习网站：https://tour.golang.org
对应的中文版：https://tour.go-zh.org
这周主要学习内容是刷了一遍上面这个教程，虽然够官方，但讲解并不细致，很多需要自行 google
顺便，第一次打开教程和在线运行代码都需要科学上网，但打开一次后所有内容就都被缓存下来了，火车上都可以翻页学习。也不方便的话可以用中文版，或者本地安装，教程上也都有说。
知识点记录 go 项目结构  必须要有 package import 用的是字符串 首字母大写的是导出名(exported name)，可以被别的包使用，有点类似于 python 的 all 只有 package main 可以被直接运行 运行入口 func main() {}  基础部件  函数以 func 定义，每个参数后必须带类型，必须规定返回值类型，可返回多个值，返回值可预先命名，函数是第一类对象(first class object) 变量以 var 定义，定义时必须规定类型，可在定义时赋值，函数内的变量可以不用 var 而用 := 来定义+赋值 常量以 const 定义，不能使用 := 语法，仅支持基础类型 基础类型是 bool, string 和各种数字，byte = uint8, tune = int32 类似于 null, None 的，是 nil  语法  if 不需要小括号，但必须有大括号；if 中可以有一条定义变量的语句，此变量仅在 if 和 else 中可用 for 是唯一的循环结构，用法基本等同于 Java 里的 for + while，同样没有小括号，但有大括号，for {} 是无限循环 switch 的每个 case 后等同于自带 break，但可以用 fallthrough 直接跳过判断而执行下一条 case 内的语句；没有匹配到任何一个 case 时会运行 default 里的内容；没有条件的 switch 可以便于改写 if-elseif-else defer 可将其后的函数推迟到外层函数返回之后再执行，多个 defer 会被压入栈中，后进先出执行 select-case 语句可同时等待多个 chan，并在所有准备好的 case 中随机选一个执行 for-range 可以对 array, map, slice, string, chan 进行遍历 make 可用来为 slice, map, chan 类型分配内存及初始化对象，返回一个引用，对这三种类型使用make时，后续参数含义均不同  其他数据类型  pointer 类似 C，没有指针运算 struct 内的字段使用 .</description>
    </item>
    
    <item>
      <title>代码「阅读」覆盖率</title>
      <link>https://codenow.me/articles/code-reading-coverage/</link>
      <pubDate>Fri, 22 Mar 2019 10:42:05 +0800</pubDate>
      
      <guid>https://codenow.me/articles/code-reading-coverage/</guid>
      <description>最近本人在阅读一些开源项目的代码，说到如何阅读开源代码，特别是超出自己能力范围的开源项目，可以说的内容还是挺多的。今天分享一个比较「偏」的：代码「阅读」覆盖率。
看一个代码库，刚开始可能是一头雾水，再咬咬牙坚持一下，一般能梳理出大致的脉络，比如服务的启动流程是怎样的，服务主要由那几个组件构成，它们之间是如何通信协作的。再往后则是一点一点了解代码是如何支持各种不同场景的，加深对代码的理解。代码「阅读」覆盖率在第三个阶段会有一定的帮助。
所谓的代码「阅读」覆盖率，和代码测试覆盖率概念类似，后者统计的是运行测试时哪些代码被运行过，所占比例是多少，前者统计的则是哪些行代码已经理解了，哪些还不理解。通过阅读覆盖率的统计，我们能更好衡量对代码库的了解程度，增加我们深入阅读代码的乐趣。
为了实现阅读覆盖率的统计，我开发了一个简陋的浏览器插件，主要有以下功能：
功能一：基于 github，支持在 github 代码页面中标记哪些代码已经理解，效果如下图所示：
直接借助 github 代码页面来显示代码理解情况，直接扩展 github 自带的菜单，增加标记功能 （图中的 mark as read 和 mark as unread 菜单项），这样能够减少一些工作量。
功能二：统计代码阅读覆盖率
效果如下所示：
在文件列表和代码界面显示百分比。
目前插件还很简陋，不过实现方式很简单，就不分享代码了，感兴趣的同学可以自己试着开发一个。
小结，阅读学习开源代码是一种比较硬核的游戏，增加阅读覆盖率的统计，是为了给这个硬核游戏添加一些可视化元素，就像塞尔达荒野之息里的地图，你能通过它看到自己探索了哪些神庙。这类手段可以延长游戏成就带来的快感，每次当我理解了一些代码后去把它们标记出来，还是很开心的，每次对代码渐渐失去兴趣时，看到统计的百分比还比较低，就又有了研究的动力。</description>
    </item>
    
  </channel>
</rss>