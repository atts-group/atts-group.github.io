<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on ATTS</title>
    <link>https://codenow.me/algorithm/</link>
    <description>Recent content in 算法 on ATTS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 15 Mar 2019 07:28:29 +0000</lastBuildDate>
    
	<atom:link href="https://codenow.me/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode: 709 To Lower Case</title>
      <link>https://codenow.me/algorithm/to_lowercase/</link>
      <pubDate>Sun, 07 Apr 2019 14:12:27 +0900</pubDate>
      
      <guid>https://codenow.me/algorithm/to_lowercase/</guid>
      <description>题号：709 难度：easy 链接：原题 描述：使用 ASCII 把字母统一为小写 class Solution: &amp;#34;&amp;#34;&amp;#34;use ASCII to return the same str in lowercase &amp;#34;&amp;#34;&amp;#34; def to_lower_case(self, str: str) -&amp;gt; str: new_str = &amp;#39;&amp;#39; for c in str: if 65 &amp;lt;= ord(c) &amp;lt;= 90: # Uppercase is between 65 and 90 in ASCII table c = chr(ord(c)+32) new_str += c return new_str # one line solution #return &amp;#39;&amp;#39;.join(chr(ord(c) + 32) if 65 &amp;lt;= ord(c) &amp;lt;= 90 else c for c in str) if __name__ == &amp;#39;__main__&amp;#39;: solution = Solution() s = &amp;#39;Hero&amp;#39; solution.</description>
    </item>
    
    <item>
      <title>Leetcode 165: Compare Version Numbers</title>
      <link>https://codenow.me/algorithm/leetcode_165_compare-version-numbers/</link>
      <pubDate>Sun, 31 Mar 2019 22:17:14 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_165_compare-version-numbers/</guid>
      <description> 题号：165
难度：medium
链接：https://leetcode-cn.com/problems/compare-version-numbers/
 class Solution: def compareVersion(self, version1: str, version2: str) -&amp;gt; int: vers1 = version1.split(&amp;#34;.&amp;#34;) vers2 = version2.split(&amp;#34;.&amp;#34;) diff = len(vers1) - len(vers2) if diff &amp;gt; 0: vers2 += [&amp;#39;0&amp;#39;] * abs(diff) elif diff &amp;lt; 0: vers1 += [&amp;#39;0&amp;#39;] * abs(diff) else: pass for i, v1 in enumerate(vers1): v1, v2 = int(v1), int(vers2[i]) if v1 &amp;gt; v2: return 1 elif v1 &amp;lt; v2: return -1 else: continue return 0</description>
    </item>
    
    <item>
      <title>Leetcode_12_IntegerToRoman</title>
      <link>https://codenow.me/algorithm/leetcode_12_integertoroman/</link>
      <pubDate>Sun, 31 Mar 2019 21:38:00 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_12_integertoroman/</guid>
      <description>题号：12 难度：medium 链接：https://leetcode.com/problems/integer-to-roman 描述：阿拉伯数字转罗马数字(1-3999)
 class Solution: &amp;quot;&amp;quot;&amp;quot;这道题的点在于，1/10/100/1000是可以重复的，其他数字是不可以重复的，如果用循环处理的话，要注意这一点&amp;quot;&amp;quot;&amp;quot; def intToRoman1(self, num: int) -&amp;gt; str: &amp;quot;&amp;quot;&amp;quot;照例先撸一个无脑的出来 这个还算快，不过占用空间比较大 &amp;quot;&amp;quot;&amp;quot; ten = [&#39;&#39;, &#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;] roman = &#39;&#39; m, num = divmod(num, 1000) roman += &#39;M&#39; * m if num &amp;gt;= 900: roman += &#39;CM&#39; num -= 900 elif num &amp;gt;= 500: roman += &#39;D&#39; num -= 500 elif num &amp;gt;= 400: roman += &#39;CD&#39; num -= 400 c, num = divmod(num, 100) roman += &#39;C&#39; * c if num &amp;gt;= 90: roman += &#39;XC&#39; num -= 90 elif num &amp;gt;= 50: roman += &#39;L&#39; num -= 50 elif num &amp;gt;= 40: roman += &#39;XL&#39; num -= 40 x, num = divmod(num, 10) roman += &#39;X&#39; * x + ten[num] return roman def intToRoman(self, num: int) -&amp;gt; str: &amp;quot;&amp;quot;&amp;quot;看了一下 discuss，有个更简洁的，同样够快且占用空间大&amp;quot;&amp;quot;&amp;quot; M = (&#39;&#39;, &#39;M&#39;, &#39;MM&#39;, &#39;MMM&#39;) C = (&#39;&#39;, &#39;C&#39;, &#39;CC&#39;, &#39;CCC&#39;, &#39;CD&#39;, &#39;D&#39;, &#39;DC&#39;, &#39;DCC&#39;, &#39;DCCC&#39;, &#39;CM&#39;) X = (&#39;&#39;, &#39;X&#39;, &#39;XX&#39;, &#39;XXX&#39;, &#39;XL&#39;, &#39;L&#39;, &#39;LX&#39;, &#39;LXX&#39;, &#39;LXXX&#39;, &#39;XC&#39;) I = (&#39;&#39;, &#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, &#39;VI&#39;, &#39;VII&#39;, &#39;VIII&#39;, &#39;IX&#39;) return M[num // 1000] + C[(num % 1000) // 100] + X[(num % 100) // 10] + I[num % 10] if __name__ == &#39;__main__&#39;: print(Solution().</description>
    </item>
    
    <item>
      <title>Leetcode: 210 Course Schedule II</title>
      <link>https://codenow.me/algorithm/leetcode-210-course-schedule-ii/</link>
      <pubDate>Sun, 31 Mar 2019 13:16:57 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode-210-course-schedule-ii/</guid>
      <description>原题链接：210. Course Schedule II 。一道基础拓扑排序题，代码如下：
class Solution: def findOrder(self, numCourses: &amp;#39;int&amp;#39;, prerequisites: &amp;#39;List[List[int]]&amp;#39;) -&amp;gt; &amp;#39;List[int]&amp;#39;: degrees = [0] * numCourses graph = [[] for _ in range(numCourses)] for edge in prerequisites: source, dep = edge degrees[source] += 1 graph[dep].append(source) stack = [] for i in range(numCourses): deps = degrees[i] if deps == 0: stack.append(i) ret = [] while len(stack) &amp;gt; 0: node = stack.pop() ret.append(node) deps = graph[node] for dep in deps: degrees[dep] -= 1 if degrees[dep] == 0: stack.</description>
    </item>
    
    <item>
      <title>DecisionTree</title>
      <link>https://codenow.me/algorithm/decision_tree/</link>
      <pubDate>Sat, 30 Mar 2019 10:39:56 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/decision_tree/</guid>
      <description>决策树 学习并构建决策树。
决策树的一个重要任务是为了数据中心所蕴含的知识信息，因此决策树可以使用不熟悉的数据集合，并从中提取出一系列规则。在这些机器根据数据创建规则时，就是机器学习的过程。专家系统中经常使用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。
决策树示例：
决策树函数组成部分    优缺点 说明     优点 计算复杂度不高、输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据   缺点 可能会产生过度匹配问题   适用数据类型 数值型和标称型     寻找最佳划分特征值
构造决策树时，需要考虑的第一个问题：当前数据集中哪个特征在划分数据分类时起到决定作用。
为了找到这个特征，需要评估每一个特征，完成评测后，原始数据就会被划分为几个数据子集。然后遍历每个数据子集，若是都为同类，则该数据集结束分类，否则在该数据集中重新执行评估，二次分类。依次执行，直到数据被划分完毕或特征使用完毕时停止。
创建分支的伪代码函数createBranch如下图所示：
检测数据集中的每个子项是否属于同一分类： if so return 类标签： else: 寻找划分数据集的最好特征 划分数据集 创建分支节点 for每个划分的子集 调用函数createBranch并增加返回结果到分支节点中 return 分支节点  信息增益
划分数据集最大的原则是：将无序的数据变得更加有序。本章选取信息论度量信息。
在划分数据集之前之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最好的特征就是最好的选择。
1).计算给定数据集的香农熵 计算熵的公式： $$ H = -\sum{i=1}^{n}P(x{i})log{2}^{P(x{i})} $$
from math import log def calcShannonEnt(dataSet): numEntries = len(dataSet) # 获取数据集中实例总数 labelCounts = {} # 创建数据字典，键值为数据集最后一列的值，即标签  for featVec in dataSet: currentLabel = featVec[-1] # 获取标签 if currentLabel not in labelCounts.</description>
    </item>
    
    <item>
      <title>Leetcode：905 Sort Array ByParity</title>
      <link>https://codenow.me/algorithm/leetcode_905_sort_array_by_parity/</link>
      <pubDate>Sat, 30 Mar 2019 00:29:38 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_905_sort_array_by_parity/</guid>
      <description>题号：905
难度：Easy
链接：https://leetcode.com/problems/sort-array-by-parity/
 如下是 python3 代码:
#!/usr/bin/python class Solution: def sortArrayByParity(self, A: &amp;#39;List[int]&amp;#39;) -&amp;gt; &amp;#39;List[int]&amp;#39;: lens = len(A) store_list = [None] * lens head = 0 tail = lens - 1 for i in range(lens): if A[i] % 2 == 0: store_list[head] = A[i] head += 1 else: store_list[tail] = A[i] tail -= 1 return store_list if __name__ == &amp;#39;__main__&amp;#39;: test_list = [3, 1, 2, 4] print(Solution().</description>
    </item>
    
    <item>
      <title>Leetcode: 146 LRU Cache</title>
      <link>https://codenow.me/algorithm/leetcode_146_lru_cached/</link>
      <pubDate>Sun, 24 Mar 2019 23:44:56 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_146_lru_cached/</guid>
      <description>题号：146
难度：hard
链接：https://leetcode-cn.com/problems/lru-cache/
 使用双向链表+map，O(1) 时间复杂度内完成 get 和 put 操作
class Node: &amp;#34;&amp;#34;&amp;#34; 双链表节点 &amp;#34;&amp;#34;&amp;#34; def __init__(self, key, val): self.val = val self.key = key self.next = None self.prev = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.head = None self.tail = None self.index = {} def get(self, key: int) -&amp;gt; int: node = self.index.get(key) if node == None: return -1 if node.prev == None: # 这是一个表头节点 return node.</description>
    </item>
    
    <item>
      <title>Leetcode: 11 Container with most water</title>
      <link>https://codenow.me/algorithm/leetcode_11_container_with_most_water/</link>
      <pubDate>Sun, 24 Mar 2019 22:13:32 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_11_container_with_most_water/</guid>
      <description>题号：11
难度：medium
链接：https://leetcode.com/problems/container-with-most-water 如下是 python3 代码
 from typing import List class Solution(object): def maxArea01(self, height: List[int]) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34;先撸一个暴力的&amp;#34;&amp;#34;&amp;#34; max_area = 0 for i, a1 in enumerate(height): for j, a2 in enumerate(height[i + 1:]): max_area = max(max_area, min(a1, a2) * (j + 1)) return max_area def maxArea02(self, height: List[int]) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34;从左右往中间压缩。由于总面积是较短的一根决定的 考虑到，如果 height[left] &amp;lt; height[right] 那么即使 right -= 1，max_area 也不会超过当前面积， 反而 left += 1，面积还有可能更大，因此此时应 left += 1 另一个方向的判断同理 &amp;#34;&amp;#34;&amp;#34; max_area = 0 left = 0 right = len(height) - 1 while left &amp;lt; right: if height[left] &amp;lt; height[right]: max_area = max(max_area, height[left] * (right - left)) left += 1 else: max_area = max(max_area, height[right] * (right - left)) right -= 1 return max_area if __name__ == &amp;#39;__main__&amp;#39;: data = [1, 8, 6, 2, 5, 4, 8, 3, 7] print(Solution().</description>
    </item>
    
    <item>
      <title>Leetcode: 62. Unique Paths by jarvys</title>
      <link>https://codenow.me/algorithm/leetcode_62._unique_paths_by_jarvys/</link>
      <pubDate>Thu, 21 Mar 2019 11:20:10 +0800</pubDate>
      
      <guid>https://codenow.me/algorithm/leetcode_62._unique_paths_by_jarvys/</guid>
      <description>62. Unique Paths 是一道基础动规题，递推公式：f(x,y) = f(x+1,y) + f(x, y+1)。我用递归 + memo 的方式完成的，代码如下：
class Solution(object): def fn(self, i, j, rows, cols, memo): if j &amp;gt;= cols or i &amp;gt;= rows: return 0 if j == cols - 1 or i == rows - 1: return 1 if memo[i][j] is None: memo[i][j] = self.fn(i+1,j,rows,cols,memo) + self.fn(i,j+1,rows,cols,memo) return memo[i][j] def uniquePaths(self, m, n): &amp;#34;&amp;#34;&amp;#34; :type m: int :type n: int :rtype: int &amp;#34;&amp;#34;&amp;#34; if m == 1 and n == 1: return 1 memo = [] for i in range(n): r = [] for j in range(m): r.</description>
    </item>
    
  </channel>
</rss>