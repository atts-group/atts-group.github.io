[{"location":"https://codenow.me/","text":"","title":"ATTS Group"},{"location":"https://codenow.me/articles/","text":"","title":"文章"},{"location":"https://codenow.me/algorithm/","text":"","title":"算法"},{"location":"https://codenow.me/translation/","text":"","title":"翻译"},{"location":"https://codenow.me/tips/","text":"","title":"Tips"},{"location":"https://codenow.me/rules/","text":"","title":"玩法"},{"location":"https://codenow.me/joinus/","text":"","title":"加入我们"},{"location":"https://codenow.me/tips/go-pptof/","text":"使用 go tool pptof 可以 debug 程序\n需要在程序中先 import\nimport _ \u0026#34;net/http/pprof\u0026#34; 然后启动一个 goroutine 用于远程访问\ngo func() { log.Println(http.ListenAndServe(\u0026#34;localhost:6060\u0026#34;, nil)) }() 最后我们就可使用 http 抓取一些关键指标\n go tool pprof http://localhost:6060/debug/pprof/heap go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30 go tool pprof http://localhost:6060/debug/pprof/block wget http://localhost:6060/debug/pprof/trace?seconds=5 go tool pprof http://localhost:6060/debug/pprof/mutex  ","title":"Go tool pptof"},{"location":"https://codenow.me/translation/migrating-projects-from-dep-to-go-modules/","text":" 原文地址\nGo Modules 是 Go 管理的未来方向。已经在 Go 1.11 中可以试用，将会是 Go 1.13 中的默认行为。\n我不会在这篇文章中描述包管理工具的工作流程。我会主要讨论的是如何把现有的项目中 dep 迁移的 Go Module。\n在我的实例中，我会使用一个私有的仓库地址 github.com/kuinta/luigi ，它是使用 Go 语言编写，在好几个项目中被使用，是一个绝佳的候选人。\n首先，我们需要初始化 Module：\ncd github.com/kounta/luigi go mod init github.com/kounta/luigi 完成后只会有两行输出：\ngo: create now go.mod: module github.com/kounta/luigi go: copying requirments from Gopkg.lock 是的，这样就对了。这样就已经完成从 dep 迁移了。\n现在你只要看一眼新生成的文件 go.mod 就像下面这样：\nmodule github.com/kounta/luigi go 1.12 require ( github.com/elliotchance/tf v1.5.0 github.com/gin-gonic/gin v1.3.0 github.com/go-redis/redis v6.15.0+incompatible )  其实在 require 中还有更多的内容，为了保持整洁我把他们删除了。\n就像 dep 区分 toml 和 lock 文件一样。我们需要生成 go.sum 文件，只要执行：\ngo build 现在你可以删除 Gopkg.lock 和 Gopkg.toml 文件，然后提交 go.mod 和 go.sum 文件。\nTravis CI 如果你使用 Travis CI，你需要在 Go 1.13 之前通过设置环境变量来启用该功能。\nGO111MODULE=on  私有仓库 如果你要导入私有仓库，你可以会发现这个错误：\ninvalid module version \u0026quot;v6.5.0\u0026quot;: unknown revision v6.5.0  这是一个误导。它真正想说的，无法识别这个 URL (在这里是指的是 github.com)。无法找到这个仓库是因为 Github 没有权限确认仓库的存在。\n修复这个问题也很简单：\n 登录 Github 账号，然后到 Setting -\u0026gt; Personal access tokens 创建一个有访问私有仓库权限的 token 然后执行  export GITHUB_TOKEN=xxx git config --global url.\u0026#34;https://${GITHUB_TOKEN}:x-oauth-basic@github.com/kounta\u0026#34;.insteadOf \u0026#34;https://github.com/kounta\u0026#34;","title":"把项目从 Dep 迁移到 Go Modules"},{"location":"https://codenow.me/algorithm/leetcode_146_lru_cached/","text":" 题号：146\n难度：hard\n链接：https://leetcode-cn.com/problems/lru-cache/\n 使用双向链表+map，O(1) 时间复杂度内完成 get 和 put 操作\nclass Node: \u0026#34;\u0026#34;\u0026#34; 双链表节点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, key, val): self.val = val self.key = key self.next = None self.prev = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.head = None self.tail = None self.index = {} def get(self, key: int) -\u0026gt; int: node = self.index.get(key) if node == None: return -1 if node.prev == None: # 这是一个表头节点 return node.val if node.next == None: # 这是一个尾节点，需要移动到头结点 if len(self.index) == 2: # 如果这是只有两个节点的链表 self.head = node self.tail = node.prev self.head.next = self.tail self.tail.prev = self.head else: self.tail = node.prev self.tail.next = None node.next = self.head self.head.prev = node self.head = node return self.head.val # 中间节点 node.prev.next = node.next node.next.prev = node.prev node.prev = None node.next = self.head self.head.prev = node self.head = node return self.head.val def put(self, key: int, value: int) -\u0026gt; None: node = self.index.get(key) if node: # 如果存在先删除 if len(self.index) == 1: # 如果只有一个直接删除就好 self.head = None self.tail = None self.index.pop(node.key) elif node.next == None: # 删除尾节点，需要修复一下 self.tail self.tail = node.prev self.tail.next = None self.index.pop(node.key) elif node.prev == None: # 删除头结点，需要修复一下 self.head self.head = node.next self.head.prev = None self.index.pop(node.key) else: # 删除中间节点 node.prev.next = node.next node.next.prev = node.prev self.index.pop(node.key) else: # 如果 capacity 不够要删除尾节点 if len(self.index) \u0026gt;= self.capacity: if len(self.index) == 1: self.head = None self.tail = None self.index = {} else: node = self.tail self.tail = node.prev self.tail.next = None self.index.pop(node.key) # 构建一个新的节点，插入到头部 node = Node(key, value) if len(self.index) == 0: self.head = node self.tail = node self.index[key] = node elif len(self.index) == 1: # 如果当前只有一个节点 self.head = node self.head.next = self.tail self.tail.prev = self.head self.index[key] = node else: node.next = self.head self.head.prev = node self.head = node self.index[key] = node ","title":"Leetcode: 146 LRU Cache"},{"location":"https://codenow.me/articles/rmdbs-tree-datastruct/","text":"在关系型数据库中存储树形结构是比较麻烦的事情，因为数据库都是基于行存储的结构，要满足树形数据结构的添加、删除、查询、修改是一件比较棘手的事情。\n已经有一些解决方案可以解决：\n这篇文章介绍一下，使用「闭包表」来处理树形结构存储。\n选择「闭包表」主要是基于查询、插入、删除、移动都比较简单，更要的是都可以使用一条 SQL 就能处理完成。\nCREATE TABLE Comments ( comment_id SERIAL PRIMARY KEY, comment TEXT NOT NULL ); 树形结构典型就是评论和部门成员关系，以评论为例，我们同时又要支持完整增删改查的功能，大致结构如下： 为了满足这种复杂的关系，需要有另外一个表来存储这种结构。\nCREATE TABLE TreePaths ( ancestor BIGINT NOT NULL, descendant BIGINT NOT NULL, PRIMARY KEY(ancestor, descendant), FOREIGN KEY (ancestor) REFERENCES Comments(comment_id), FOREIGN KEY (descendant) REFERENCES Comments(comment_id) ); ancestor 作为每个评论节点的祖先，descendant 作为每个评论节点的后代。\n 这里的祖先和后代都是泛指所有祖先和后代，而不是特指直接的祖先和后代\n 接着构造一批数据插入 Comments 和 Tree Paths 中\ninsert into comments(comment_id, comment) values (1, \u0026#39;这个 Bug 的成因 是什么\u0026#39;); insert into comments(comment_id, comment) values (2, \u0026#39;我觉得是一个空指针\u0026#39;); insert into comments(comment_id, comment) values (3, \u0026#39;不，我查过了\u0026#39;); insert into comments(comment_id, comment) values (4, \u0026#39;我们需要查无效输入\u0026#39;); insert into comments(comment_id, comment) values (5, \u0026#39;是的，那是个问题\u0026#39;); insert into comments(comment_id, comment) values (6, \u0026#39;好，查一下吧\u0026#39;); insert into comments(comment_id, comment) values (7, \u0026#39;解决了\u0026#39;); insert into treepaths(ancestor, descendant) values (1, 1); insert into treepaths(ancestor, descendant) values (1, 2); insert into treepaths(ancestor, descendant) values (1, 3); insert into treepaths(ancestor, descendant) values (1, 4); insert into treepaths(ancestor, descendant) values (1, 5); insert into treepaths(ancestor, descendant) values (1, 6); insert into treepaths(ancestor, descendant) values (1, 7); insert into treepaths(ancestor, descendant) values (2, 2); insert into treepaths(ancestor, descendant) values (2, 3); insert into treepaths(ancestor, descendant) values (3, 3); insert into treepaths(ancestor, descendant) values (4, 4); insert into treepaths(ancestor, descendant) values (4, 5); insert into treepaths(ancestor, descendant) values (4, 6); insert into treepaths(ancestor, descendant) values (4, 7); insert into treepaths(ancestor, descendant) values (5, 5); insert into treepaths(ancestor, descendant) values (6, 6); insert into treepaths(ancestor, descendant) values (6, 7); insert into treepaths(ancestor, descendant) values (7, 7); 这里需要解释一下 treepaths 存储关系的逻辑：\n 每个节点和自己建立一个关系，也就是 ancestor 和 descendant 都是自己 每个节点和自己祖先建立关系，也就是 ancestor 指向所有祖先节点 每个节点和自己后代建立关系，也就是 descendant 指向所有的后代节点  以上关系建立完毕之后，就能以树形关系查询 comments 表中的数据，比如要查询 comment_id = 4 所有的子节点：\nSELECT c.* FROM Comments AS c JOIN TreePaths AS t ON c.comment_id = t.descendant WHERE t.ancestor = 4; 或者要查询 comment_id = 4 所有的父节点：\nSELECT c.* FROM Comments AS c JOIN TreePaths AS t ON c.comment_id = t.ancestor WHERE t.descendant = 4; 假如要在 comment_id= 5 后插入一个新的节点，先要插入关联到自己的关系，然后从 TreePaths 找出中 descendant 为 5 节点。意思就是找出 comment_id = 5 的祖先和新节点在 TreePaths 关联上.\ninsert into comments(comment_id, comment) values (8, \u0026#39;对的是这个问题，我已经修复了\u0026#39;); INSERT INTO TreePaths (ancestor, descendant) SELECT t.ancestor, 8 FROM TreePaths AS t WHERE t.descendant = 5 UNION ALL SELECT 8, 8; 如果要删除 comment_id = 7 这个节点，只需要在 TreePaths 删除 descendant = 7 的记录即可，这时候不用我们维护节点和节点之间的关系，所以很方便\nDELETE FROM TreePaths WHERE descendant = 7; 假如要删除 comment_id = 4 这颗完整的树，只需要找出这个 root 节点所有的后代删除即可。\nDELETE FROM TreePaths WHERE descendant IN (SELECT descendant FROM TreePaths WHERE ancestor = 4); 如果是移动一个节点，只需要删除然后再添加即可，这时候自身的引用可以不用删除。\n比较复杂的是移动一棵树，要先找到这棵树的根节点，然后移除所有子节点和他们祖先的关系，比如把 comment_id = 6 移动到 commint_id = 3 下。\n首先把在 TreePaths 把所有关系移除\nDELETE FROM TreePaths WHERE descendant IN (SELECT descendant FROM TreePaths WHERE ancestor = 6) AND ancestor IN (SELECT ancestor FROM TreePaths WHERE descendant = 6 AND ancestor != descendant); 然后在 commint_id = 3 插入新关系，同时所有子节点要和 commint_id = 3 的祖先建立关系\nINSERT INTO TreePaths (ancestor, descendant) SELECT supertree.ancestor, subtree.descendant FROM TreePaths AS supertree CROSS JOIN TreePaths AS subtree WHERE supertree.descendant = 3 AND subtree.ancestor = 6; 使用一开始查询的 SQL，可以看出移动过去了\n","title":"使用 RMDBS 存在树结构数据"},{"location":"https://codenow.me/articles/goexercise-of-a-tour-of-go/","text":" 这周学了学 golang，做个记录\n学习网站：https://tour.golang.org\n对应的中文版：https://tour.go-zh.org\n这周主要学习内容是刷了一遍上面这个教程，虽然够官方，但讲解并不细致，很多需要自行 google\n顺便，第一次打开教程和在线运行代码都需要科学上网，但打开一次后所有内容就都被缓存下来了，火车上都可以翻页学习。也不方便的话可以用中文版，或者本地安装，教程上也都有说。\n知识点记录 go 项目结构  必须要有 package import 用的是字符串 首字母大写的是导出名(exported name)，可以被别的包使用，有点类似于 python 的 all 只有 package main 可以被直接运行 运行入口 func main() {}  基础部件  函数以 func 定义，每个参数后必须带类型，必须规定返回值类型，可返回多个值，返回值可预先命名，函数是第一类对象(first class object) 变量以 var 定义，定义时必须规定类型，可在定义时赋值，函数内的变量可以不用 var 而用 := 来定义+赋值 常量以 const 定义，不能使用 := 语法，仅支持基础类型 基础类型是 bool, string 和各种数字，byte = uint8, tune = int32 类似于 null, None 的，是 nil  语法  if 不需要小括号，但必须有大括号；if 中可以有一条定义变量的语句，此变量仅在 if 和 else 中可用 for 是唯一的循环结构，用法基本等同于 Java 里的 for + while，同样没有小括号，但有大括号，for {} 是无限循环 switch 的每个 case 后等同于自带 break，但可以用 fallthrough 直接跳过判断而执行下一条 case 内的语句；没有匹配到任何一个 case 时会运行 default 里的内容；没有条件的 switch 可以便于改写 if-elseif-else defer 可将其后的函数推迟到外层函数返回之后再执行，多个 defer 会被压入栈中，后进先出执行 select-case 语句可同时等待多个 chan，并在所有准备好的 case 中随机选一个执行 for-range 可以对 array, map, slice, string, chan 进行遍历 make 可用来为 slice, map, chan 类型分配内存及初始化对象，返回一个引用，对这三种类型使用make时，后续参数含义均不同  其他数据类型  pointer 类似 C，没有指针运算 struct 内的字段使用 . 访问 array 必须有长度，且内部所有值类型必须相同 slice 类似数组的引用，可动态调整长度，有 len 和 cap 两个属性，零值是 nil，用 append 函数可以追加元素及自动扩展 cap map 在获取值的时候可以用 value, ok = m[key] 来校验 key 是否存在 method 与 function 略有不同，需要有一个 receiver，若 receiver 为指针，则可以在方法中修改其指向的值。只能为定义在当前包的类型定义 method interface 类型被实现时无需显示说明，任何类型只要实现了其所有方法就认为其实现了此接口，没有 implements 关键字；可以用空接口来接收任意值 interface{} interface value 是一个tuple(value, type)，可以用 t, i = i.(T) 来校验类型，switch 中可以用 v := i.(type) 来判断其类型 channel 用来在 goroutines 直接传递信息，被 close 后可以用 for-range 遍历 常见 interface: stringer, error, reader, writer  goroutine  用 go 来启动一个 goroutine 用 chan 来在不同 goroutine 之间交流 select-case 语句可以同时等待多个 chan，并在所有准备好的 case 中随机选一个运行 sync.Mutex 互斥锁可用来保证多个 goroutine 中每次只有一个能够访问共享的变量  其他规则  所有的大括号里，前括号不允许单独成一行 推荐使用 tab 而非空格 没有 class 概念，用 struct + method 实现 变量定义了就必须要使用，否则通不过编译  A Tour of Go 里的内容大概就这些，可能还有些遗漏的细节，我也不打算再去补充上了\n这里还提供了 11 个练习，我也顺着做了过来，感觉就跟上学时的课后习题一样，熟悉的感觉让人感动\n我的解答以及相关内容放到了 WokoLiu/go-tour-exercise\n如果有朋友要学 golang 的话，希望能有些帮助\n","title":"[Go]Exercise of a Tour of Go"},{"location":"https://codenow.me/tips/mysqlis-varchar-a-number/","text":"判断 MySQL 里一个 varchar 字段的内容是否为数字：\nselect * from table_name where length(0+name) = length(name);","title":"[Mysql]Is Varchar a Number?"},{"location":"https://codenow.me/algorithm/leetcode-11.-container-with-most-water/","text":" 题号：11\n难度：medium\n链接：https://leetcode.com/problems/container-with-most-water\n 如下是 python3 代码\nfrom typing import List class Solution(object): def maxArea01(self, height: List[int]) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;先撸一个暴力的\u0026#34;\u0026#34;\u0026#34; max_area = 0 for i, a1 in enumerate(height): for j, a2 in enumerate(height[i + 1:]): max_area = max(max_area, min(a1, a2) * (j + 1)) return max_area def maxArea02(self, height: List[int]) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;从左右往中间压缩。由于总面积是较短的一根决定的 考虑到，如果 height[left] \u0026lt; height[right] 那么即使 right -= 1，max_area 也不会超过当前面积， 反而 left += 1，面积还有可能更大，因此此时应 left += 1 另一个方向的判断同理 \u0026#34;\u0026#34;\u0026#34; max_area = 0 left = 0 right = len(height) - 1 while left \u0026lt; right: if height[left] \u0026lt; height[right]: max_area = max(max_area, height[left] * (right - left)) left += 1 else: max_area = max(max_area, height[right] * (right - left)) right -= 1 return max_area if __name__ == \u0026#39;__main__\u0026#39;: data = [1, 8, 6, 2, 5, 4, 8, 3, 7] print(Solution().maxArea02(data))","title":"Leetcode: 11 Container with most water"},{"location":"https://codenow.me/tips/tips-for-adding-debug-logs/","text":"之所以整理这方面的小技巧，主要是 golang 的开源项目都是像 TiDB、etcd 这种偏低层的分布式服务。用 debugger 来跟踪代码是比较困难的，容易出错，而且还容易遇到坑，比如：有的 golang 版本无法正确输出调试信息，mac 上有些开源项目调试模式无法正常运行等等。用日志的话，更简单直接，不容易遇到坑。只不过，在查看变量、查看调用栈方面是真不太方便，下面几个小技巧能够弥补一些吧。\n查看调用栈\n可以使用 debug.Stack() 方法获取调用栈信息，比如像下面这样：\nlog.Printf(\u0026#34;stack of function xxx: %v\u0026#34;, string(debug.Stack())) 不过，在日志中打印调用栈的方法还是要慎用，输出内容有时候太长了，影响日志的连贯性。可以考虑将栈信息再做一下处理，只保留最上面几层的调用信息。\n查看变量类型\n可以使用 %T 来查看变量类型，很多时候可以像下面这样简单查看一下变量的类型和取值：\nlog.Printf(\u0026#34;DEBUG: node type: %T, value: %v\u0026#34;, n, n) 使用 buffer 来收集要查看的变量信息\n有的时候，我们需要查看的不是一个变量，可能是多个变量或者一个复杂数据结构中的一部分字段，如果代码中没有给出满足需求的 String 方法的话，可以考虑用 buffer，自己一点点收集，就像下面这样：\nbuf := bytes.NewBufferString() fmt.Fprintf(buf, \u0026#34;a: %v, \u0026#34;, a) fmt.Fprintf(buf, \u0026#34;b.child: %v, \u0026#34;, b) fmt.Fprintf(buf, \u0026#34;c.parent: %v, \u0026#34;, c.parent) log.Printf(\u0026#34;%v\u0026#34;, buf.String())","title":"golang 项目添加 debug 日志的小技巧"},{"location":"https://codenow.me/articles/code-reading-coverage/","text":"最近本人在阅读一些开源项目的代码，说到如何阅读开源代码，特别是超出自己能力范围的开源项目，可以说的内容还是挺多的。今天分享一个比较「偏」的：代码「阅读」覆盖率。\n看一个代码库，刚开始可能是一头雾水，再咬咬牙坚持一下，一般能梳理出大致的脉络，比如服务的启动流程是怎样的，服务主要由那几个组件构成，它们之间是如何通信协作的。再往后则是一点一点了解代码是如何支持各种不同场景的，加深对代码的理解。代码「阅读」覆盖率在第三个阶段会有一定的帮助。\n所谓的代码「阅读」覆盖率，和代码测试覆盖率概念类似，后者统计的是运行测试时哪些代码被运行过，所占比例是多少，前者统计的则是哪些行代码已经理解了，哪些还不理解。通过阅读覆盖率的统计，我们能更好衡量对代码库的了解程度，增加我们深入阅读代码的乐趣。\n为了实现阅读覆盖率的统计，我开发了一个简陋的浏览器插件，主要有以下功能：\n功能一：基于 github，支持在 github 代码页面中标记哪些代码已经理解，效果如下图所示：\n直接借助 github 代码页面来显示代码理解情况，直接扩展 github 自带的菜单，增加标记功能 （图中的 mark as read 和 mark as unread 菜单项），这样能够减少一些工作量。\n功能二：统计代码阅读覆盖率\n效果如下所示：\n在文件列表和代码界面显示百分比。\n目前插件还很简陋，不过实现方式很简单，就不分享代码了，感兴趣的同学可以自己试着开发一个。\n小结，阅读学习开源代码是一种比较硬核的游戏，增加阅读覆盖率的统计，是为了给这个硬核游戏添加一些可视化元素，就像塞尔达荒野之息里的地图，你能通过它看到自己探索了哪些神庙。这类手段可以延长游戏成就带来的快感，每次当我理解了一些代码后去把它们标记出来，还是很开心的，每次对代码渐渐失去兴趣时，看到统计的百分比还比较低，就又有了研究的动力。\n","title":"代码「阅读」覆盖率"},{"location":"https://codenow.me/translation/group-by-and-aggregation-elimination/","text":"原文链接：Group-by and Aggregation Elimination 是一篇关于数据库查询优化的文章，有几句话实在不知道咋翻译好，也影响不大，直接留下原句了。翻译如下：\nI get a fair number of questions on query transformations, and it’s especially true at the moment because we’re in the middle of the Oracle Database 12c Release 2 beta program. 有时用户可能会发现在一个执行计划里有些环节消失了或者有些反常，然后会意识到查询发生了转换 (transformation) 。举个例子，有时你会惊讶的发现，查询语句里的表和它的索引可能压根就没有出现在查询计划当中，这是连接消除 (Join Elimination) 机制在起作用。\n我相信，你已经发现查询转换是查询优化中很重要的一环，因为它经常能够通过消除一些像连接（join）、排序（sort）的步骤来降低查询的代价。有时修改查询的形式可以让查询使用不同的访问路径（access path），不同类型的连接和甚至完全不同的查询方式。在每个发布版本附带的优化器白皮书中（比如 Oracle 12c One 的），我们都介绍了大多数的查询转换模式。\n在 Oracle 12.1.0.1 中，我们增加了一种新的转换模式，叫做 Group-by and Aggregation Elimination ，之前一直没有提到。它在 Oracle 优化器中是最简单的一种查询转换模式了，很多人应该都已经很了解了。你们可能在 Mike Dietrich’s upgrade blog 中看到过关于它的介绍。让我们来看一下这种转换模式到底做了什么。\n很多应用都有用过这么一种查询，这是一种单表分组查询的形式，数据是由另一个底层的分组查询形成的视图来提供的。比如下面这个例子：\nSELECT v.column1, v.column2, MAX(v.sm), SUM(v.sm) FROM (SELECT t1.column1, t1.column2, SUM(t1.item_count) AS sm FROM t1, t2 WHERE t1.column4 \u0026gt; 3 AND t1.id = t2.id AND t2.column5 \u0026gt; 10 GROUP BY t1.column1, t1.column2) V GROUP BY v.column1, v.column2; 如果没有查询转换，这个语句可能是下面这样的查询计划。每张表里有十万行数据，查询要运行 2.09 秒:\n------------------------------------------------------ Id | Operation | Name | Rows | Bytes | ------------------------------------------------------ | 0 | SELECT STATEMENT | | | | | 1 | HASH GROUP BY | | 66521 | 1494K| | 2 | VIEW | | 66521 | 1494K| | 3 | HASH GROUP BY | | 66521 | 2143K| | 4 | HASH JOIN | | 99800 | 3216K| | 5 | TABLE ACCESS FULL| T2 | 99800 | 877K| | 6 | TABLE ACCESS FULL| T1 | 99998 | 2343K| ------------------------------------------------------  从上面的计划中，你会看到有两个 Hash Group By 步骤，一个是为了视图，一个是为了外层的查询。我用的是 12.1.0.2 版本的数据库，通过设置隐藏参数 _optimizer_aggr_groupby_elim 为 false 的方式禁用了查询转换。\n下面我们看一下查询转换生效时被转换的查询，你会发现只有一个 Hash Group By 步骤。查询时间也少了很多，只有 1.29 秒：\n---------------------------------------------------- Id | Operation | Name | Rows | Bytes | ---------------------------------------------------- | 0 | SELECT STATEMENT | | | | | 1 | HASH GROUP BY | | 66521 | 2143K| | 2 | HASH JOIN | | 99800 | 3216K| | 3 | TABLE ACCESS FULL| T2 | 99800 | 877K| | 4 | TABLE ACCESS FULL| T1 | 99998 | 2343K| ----------------------------------------------------  上面这个例子是相对比较好理解的，因为在视图中分组查询的列信息和外层查询是一样的。不一定非要是这样的形式才行。有的时候即使外层的 Group By 是视图中 Group By 的子集也是可以的。比如下面这个例子：\nSELECT v.column1, v.column3, MAX(v.column1), SUM(v.sm) FROM (SELECT t1.column1, t1.column2, t1.column3, SUM(t1.item_count) AS sm FROM t1, t2 WHERE t1.column4 \u0026gt; 3 AND t1.id = t2.id AND t2.column5 \u0026gt; 10 GROUP BY t1.column1, t1.column2, t1.column3) V GROUP BY v.column1, v.column3; ---------------------------------------------------- Id | Operation | Name | Rows | Bytes | ---------------------------------------------------- | 0 | SELECT STATEMENT | | | | | 1 | HASH GROUP BY | | 49891 | 1607K| |* 2 | HASH JOIN | | 99800 | 3216K| |* 3 | TABLE ACCESS FULL| T2 | 99800 | 877K| |* 4 | TABLE ACCESS FULL| T1 | 99998 | 2343K| ----------------------------------------------------  你不需要额外做什么操作来开启这个查询转换。它默认是被开启的，当某个查询符合条件的时候就会自动被转换。在实际的企业级系统中，这种方式一定会带来很多显著的优化。不过要注意，这种转换模式在使用了 rollup 和 cube 的分组函数时是不起作用的。\n这种转换有没有什么问题呢？是有的（这也是 Mike Dietrich 提到它的原因）。为了做这个转换，Oracle 优化器必须判断出来什么时候可以用什么时候不可以用，这背后的逻辑可能会很复杂。The bottom line is that there were some cases where the transformation was being applied and it shouldn’t have been. Generally, this was where the outer group-by query was truncating or casting columns used by the inner group-by. This is now fixed and it’s covered by patch number 21826068. Please use MOS to check availability for your platform and database version.\n","title":"Group by and Aggregation Elimination"},{"location":"https://codenow.me/algorithm/leetcode-62.-unique-paths-by-jarvys/","text":"62. Unique Paths 是一道基础动规题，递推公式：f(x,y) = f(x+1,y) + f(x, y+1)。我用递归 + memo 的方式完成的，代码如下：\nclass Solution(object): def fn(self, i, j, rows, cols, memo): if j \u0026gt;= cols or i \u0026gt;= rows: return 0 if j == cols - 1 or i == rows - 1: return 1 if memo[i][j] is None: memo[i][j] = self.fn(i+1,j,rows,cols,memo) + self.fn(i,j+1,rows,cols,memo) return memo[i][j] def uniquePaths(self, m, n): \u0026#34;\u0026#34;\u0026#34; :type m: int :type n: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if m == 1 and n == 1: return 1 memo = [] for i in range(n): r = [] for j in range(m): r.append(None) memo.append(r) return self.fn(0, 0, n, m, memo) ","title":"Leetcode: 62. Unique Paths by jarvys"},{"location":"https://codenow.me/joinus/","text":" 如何加入 email 联系: h1x2y3awalm@gmail.com\n发送你的 github 邮箱，到邮件正文，邀请到 github 组织中。\n成员列表    Github Username Email 完成次数 加入时间     zhegnxiaowai h1x2y3awalm@gmail.com 0 2019年3月18日   jarvys leguroky@gmail.com 0 2019年3月18日   tubby tubby.xue@gmail.com 0 2019年3月18日   WokoLiu banbooliu@gmail.com 0 2019年3月18日    ","title":"加入我们"},{"location":"https://codenow.me/rules/","text":" 食用指南 这是一个自发的学习小组，主要以学习为目的，提升自己的能力。\n 学习是泯灭人性的行为，所以我们要有一些强制手段来逼迫自己。\n 我们的学习计划以每周为一个周期，分成四个任务：\n 每周一个算法题：算法题可以来自任何 OJ 网站（比如 Leetcode 等），难度根据每人情况不同自己选择。 每周一篇文章翻译：翻译文章可长可短，只要和计算机相关的知识就可以。 每周一个 Tips：Tip 就是一个很小的记录，比如这周学会了什么小技巧。 每周一个分享：需要整理出一篇文章，内容不限，但是要和计算机相关，篇幅在 500 - 800 字最好。分享能成一整个系列最好。  任务时间为，周一 0 点整至周日 24 点整。统计方式以 commit 时间为准，合并到分支后会触发 CI 自动部署到该网站。\n惩罚措施 这是一个 强制 的学习计划，所以我们会有惩罚措施。\u0008惩罚措施 的 Base 为 100 元，每周的 4 个任务未完成一个需要惩罚 25 元。 惩罚的金额将会进入 惩罚基金，基金中所有的钱将会用于购买 学习资料。\n最后就是退出机制，任何人可以在 任何时候 退出或者在你未完成任务时候又不愿意缴纳惩罚时候，将会被强制清理出学习小组。\n惩罚基金在 未使用 时候会一并退回，同时删除 repo 中有关退出者的内容；如果惩罚基金已经被使用，将不会退回，需要注意。\n提交方法 首先要克隆本仓库到本地：\ngit clone --recurse-submodules https://github.com/atts-group/atts.git 任何时间都可以直接 push master 提交。\n 开始使用前你需要先安装 hugo，下载对应平台的版本即可。\n 目前有 4 个分类（type）：\n algorithm articles tips translation  新建文章需要使用 hugo new {type}/{title}.md 的方式新建，不能直接创建文件。\n 这里的 {type} 就是上面 4 个分类的其中一个，{title} 就是你写的标题\n 当写完后用使用 hugo server 来观察一下你新添加的是否正确，然后用 git push 推送的 master 分支，即可完成。\n 禁止修改非你创建的文件，特别的隐藏文件，除非你知道为什么要这么修改\n ","title":"玩法"},{"location":"https://codenow.me/","text":"","title":"ATTS Group"},{"location":"https://codenow.me/categories/","text":"","title":"Categories"},{"location":"https://codenow.me/tags/","text":"","title":"Tags"}]